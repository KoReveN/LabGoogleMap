@model MapViewModel
@using LabGoogleMap.Helpers
@using Service.RequestModels
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration
@{
    //  ViewData["Title"] = "Home Page";
    ViewBag.Title = "Google map";

    var trafficModelDataSource = EnumHelper.GetEnumDataSource<TrafficModel>().ToList();
    var markerTypeDataSource = EnumHelper.GetEnumDataSource<Domain.Entities.MarkerType>().ToList();

    var googleApiKey = Configuration["googleApi:Key"];
}




<div class="space-10"></div>



<div id="test1"></div>

<div>
    Current marker:
    @*<select id="markerType" asp-items="@Html.GetEnumSelectList(typeof(Domain.Entities.MarkerType))"></select>*@
    <div id="markerType"></div>
    <div id="colorSelect"></div>
</div>

<div class="space-20"></div>
<div class="row">

    <input id="deleteMarkers" class="btn btn-danger margin-5" type=button value="Delete all markers">
    <input id="buildRoute" class="btn btn-primary margin-5" type=button value="Build route">

    <div class="right">
        <div id="routeOptionSelect" class="margin-5"></div>
        <input id="btn-optimalRoute" class="btn margin-5" type=button value="Optimal route">
    </div>
</div>

<div class="space-20"></div>

<div id="routeTable"></div>

<div class="space-20"></div>
<div id="map"></div>




@section scripts
    {
    <script src="https://maps.googleapis.com/maps/api/js?key=@googleApiKey&libraries=geometry" defer></script>
    <script defer>
        //require(["jquery", "kendogrids", "ajax", "toastr"], function ($, kendoGrid, ajax, toastr) {

        // Settings
        var urlMapMarkerAdd = "@Url.Action("MapMarkerAdd")";
        var urlMapMarkersRemove = "@Url.Action("MapMarkersRemove")";
        var urlMapMarkerRemove = "@Url.Action("MapMarkerRemove")";
        var urlMapMarkersUpdate = "@Url.Action("MapMarkersUpdate")";
        var urlMapGetSimpleRoute = "@Url.Action("GetGoogleSimpleRoute")";
        var urlMapGetOptimalRoute = "@Url.Action("GetGoogleOptimalRoute")";
        var colorDataSource =  @Html.Raw(Json.Serialize(Model.MarkerIcons.ToArray()));

        var routeOptionsDataSource = @Html.Raw(Json.Serialize(trafficModelDataSource));
        var markerTypeDataSource = @Html.Raw(Json.Serialize(markerTypeDataSource));

        var modelMarkers = @Html.Raw(Json.Serialize(@Model.Markers.ToArray()));
        var modelLegs = [];

        var needUpdateAllIndex = false;
        var useSimpleRoute = true;


        var grid;
        var map;
        var colorDropDownList, marketTypeDropDownList;
        var markerIconUrl = "http://maps.google.com/mapfiles/kml/paddle/blu-circle.png";
        var markers = [];
        var polylines = [];

            // Actions
        var actions = {
            addMapMarker: function (data) {
                ajax.json({
                    url: urlMapMarkerAdd,
                    data: data,
                    success: function (responce) {
                        if (responce.success) {
                            if  (responce.markers.length > 1){
                                toastr.success("Updated markers index!");
                                console.log("Updated markers index!");
                                modelMarkers = responce.markers;
                                render.renderMarkersFromModel();
                            } else {
                                toastr.success("Created new marker!");
                                console.log("Created new marker!");
                                helper.addMarker(responce.markers[0]);
                                modelMarkers.push(responce.markers[0]);
                                render.gridRefresh();
                            }
                            helper.updateRoute();
                        } else {
                            toastr.error("Fail addMapMarker: " + responce.message);
                            console.log("Fail addMapMarker: " + responce.message);
                        }
                    },
                    fail: function (msg) {
                        console.log("Failed addMapMarker query.... " + msg);
                        toastr.error("Failed addMapMarker query.... " + msg);
                    }
                });
            },
            removeMarker: function (markerId) {
                ajax.json({
                    url: urlMapMarkerRemove,
                    data: markerId,
                    success: function (responce) {
                        if (responce.success) {
                            toastr.success("Marker deleted!");
                            console.log("Marker deleted!");
                            helper.modelMarkers.removeMarker(markerId);
                            helper.updateRoute();
                        } else {
                            toastr.error("Fail removeMarker: " + responce.message);
                            console.log("Fail removeMarker: " + responce.message);
                        }
                    },
                    fail: function () {
                        console.log("Failed removeMarker query....");
                        toastr.error("Failed removeMarker query....");
                    }
                });
            },
            removeMapMarkers: function () {
                ajax.json({
                    url: urlMapMarkersRemove,
                    success: function (responce) {
                        if (responce.success) {
                            toastr.success("Markers was deleted!");
                            console.log("Markers was deleted!");
                            // Clean map markers.
                            render.cleanMapMarkers();
                            markers = [];
                            modelMarkers = [];
                            render.clearPolylines();
                            render.gridRefresh();
                        } else {
                            toastr.error("Fail: " + responce.message);
                            console.log("Fail: " + responce.message);
                        }
                    },
                    fail: function () {
                        console.log("Failed removeMapMarkers query....");
                        toastr.error("Failed removeMapMarkers query....");
                    }
                });
            },
            updateMapMarkers: function(data) {
                ajax.json({
                    url: urlMapMarkersUpdate,
                    data: data,
                    success: function (responce) {
                        if (responce.success) {
                            toastr.success("Updated markers!");
                            modelMarkers = responce.markers;
                            render.renderMarkersFromModel();
                            console.log("Updated markers!");
                            useSimpleRoute ? helper.updateRoute() : render.clearPolylines();
                        } else {
                            toastr.error("Fail: " + responce.message);
                            console.log("Fail: " + responce.message);
                        }
                    },
                    fail: function (msg) {
                        console.log("Failed ajax query.... " + msg);
                        toastr.error("Failed ajax query.... " + msg);
                    }
                });
            },
            getRoute: () => {
                useSimpleRoute = true;
                ajax.json({
                    url: urlMapGetSimpleRoute,
                    data: modelMarkers,
                    success: (responce) => {
                        if (responce.success) {
                            modelLegs = responce.legs;
                            if (responce.legsFromDbCount == 0) {
                                toastr.warning ("Info: All legs are derived from google Api");
                            } else {

                                if (responce.legsFromDbCount == responce.legs.length) {
                                    toastr.success("Success: All legs found locally.");
                                } else {
                                    toastr.info(`Info: ${responce.legsFromDbCount} of ${responce.legs.length} legs found locally`);
                                    //info: partial api / db
                                    //success: all from db (LEG)
                                }
                            }
                            modelMarkers = responce.markers;
                            render.renderPolylines(modelLegs);
                            render.renderMarkersFromModel();
                            //render.gridRefresh();
                            //  helper.addMarker(responce.markers);
                            console.log("Updated route!");
                        } else {
                            toastr.error("Fail route: " + responce.message);
                            console.log("Fail route: " + responce.message);
                        }
                    },
                    fail: function (msg) {
                        console.log("Failed route query.... " + msg);
                        toastr.error("Failed route query.... " + msg);
                    }
                });
            },
            getOptimalRoute: () => {
                useSimpleRoute = false;
                var optimalRouteOption = $("#routeOptionSelect").val();
                ajax.json({
                    url: urlMapGetOptimalRoute,
                    data: {
                        markers: modelMarkers,
                        optimalRouteOption
                    },
                    success: (responce) => {
                        if (responce.success) {
                            toastr.success("Updated OptimalRoute!");
                            modelLegs = responce.otimizedRoute.legs;
                            modelMarkers = responce.otimizedRoute.markers;
                            render.renderMarkersFromModel();
                            render.renderPolylines([{ polyline: responce.otimizedRoute.polyline}]);

                            //modelLegs = responce.legs;
                            //render.renderPolylines(modelLegs);
                            //render.gridRefresh();
                            console.log("Updated OptimalRoute!");
                        } else {
                            toastr.error("Fail OptimalRoute: " + responce.message);
                            console.log("Fail OptimalRoute: " + responce.message);
                        }
                    },
                    fail: function (msg) {
                        console.log("Failed OptimalRoute query.... " + msg);
                        toastr.error("Failed OptimalRoute query.... " + msg);
                    }
                });
            },
        };

        var helper = {
            initIconsDropDownList: function () {
                colorDropDownList = $('#colorSelect').kendoDropDownList(
                    {
                        dataSource: colorDataSource.filter(x => x.color != "White"),
                        dataTextField: "color",
                        dataValueField: "iconUrl"
                    }).data('kendoDropDownList');
            },
            initMarkerTypeDropDownList: function () {
                marketTypeDropDownList = $('#markerType').kendoDropDownList(
                    {
                        dataSource: markerTypeDataSource,
                        dataTextField: "value",
                        dataValueField: "key",
                        change: () => {
                            if (marketTypeDropDownList.value() > 0) {
                                colorDropDownList.dataSource.data(colorDataSource.filter(x => x.color == "White"));
                                colorDropDownList.select(0);
                                colorDropDownList.enable(false);
                            } else if (colorDropDownList.dataSource.total() < 2){
                                colorDropDownList.enable(true);
                                colorDropDownList.dataSource.data(colorDataSource.filter(x => x.color != "White"));
                                colorDropDownList.select(0);
                            }
                        },
                    }).data('kendoDropDownList');
            },
            initRouteOptionsDropDownList: function () {
                $('#routeOptionSelect').kendoDropDownList(
                    {
                        dataSource: routeOptionsDataSource,
                        dataTextField: "value",
                        dataValueField: "key",
                    });
            },
            initRouteTable: () => {
                grid = $("#routeTable").kendoGrid(
                    {
                        sortable: true,
                        dataSource: {
                            data: modelMarkers,
                            sort: { field: "index", dir: "asc" }
                        },
                        columns: [
                            {
                                field: "markerType", title: "Point type", width: "90px" ,
                                template: function (dataItem) {
                                    switch (dataItem.markerType) {
                                        case 1:
                                            return "<strong>Start</strong>";
                                            break;
                                        case 2:
                                            return "<strong>End</strong>";
                                            break;
                                        default:
                                            return dataItem.index;
                                    }
                                },
                            },
                            { field: "point.address", title: "Address", width: "350px" },
                            { field: "point.lat", title: "Lat", width: "100px" },
                            { field: "point.lng", title: "Lng", width: "100px" },
                            { field: "markerId", title: "Distance",
                                template: (marker) => {
                                    if (modelLegs.length > 0) {
                                        var leg = modelLegs.find(x => x.startPoint == marker.pointId);
                                        if (leg != null) {
                                            return render.formatDistance(leg.distance);
                                        }
                                    }
                                    return "";
                                }
                            },
                            {
                                field: "markerId", title: "Duration",
                                template: (marker) => {
                                    if (modelLegs.length > 0) {
                                        var leg = modelLegs.find(x => x.startPoint == marker.pointId);
                                        if (leg != null) {
                                            return render.formatDuration(leg.duration);
                                        }
                                    }
                                    return "";
                                }
                            },
                            { command: { text: "Remove", click: helper.removeMarker }, title: " ", width: "100px"}
                        ],
                        sort: { field: "index", dir: "desc" }
                    }
                ).data("kendoGrid");

                //$(grid.element).kendoDraggable({
                //    filter: "tr",
                //    hint: function (e) {
                //        var item = $('<div class="k-grid k-widget" style="background-color: MediumVioletRed; color: black;"><table><tbody><tr>' + e.html() + '</tr></tbody></table></div>');
                //        return item;
                //    },

                //});

                grid.table.kendoSortable({
                    filter: ">tbody >tr",
                    hint: $.noop,
                    cursor: "move",
                    placeholder: function (element) {
                        return element.clone().addClass("k-state-hover").css("opacity", 0.65);
                    },
                    container: "#routeTable tbody",
                    change: function (e) {
                        var oldIndex = grid.dataSource.getByUid(e.item.data("uid")).index,
                            newIndex = grid.dataSource.data()[e.newIndex].index;
                        helper.modelMarkers.changeMarkerPosition(oldIndex, newIndex)
                    }
                });
            },
            initGoogleMap: function () {
                var myLatLng = { lat: 46.481, lng: 30.758 };

                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: 46.481, lng: 30.758 },
                    zoom: 12
                });


                // Add a markers from the viewModel.
                render.renderMarkersFromModel();

                //marker.setIcon(customIcon({
                //    fillColor: '#fff',
                //    strokeColor: '#000'
                //}));
            },
            createGoogleMarker: function (location, map, markerIcon, lable, markerType, index) {
                var marker = new google.maps.Marker({
                    position: location,
                    label: lable,
                    icon: {
                        url: markerIcon, //markerIconUrl
                        labelOrigin: new google.maps.Point(33, 21),
                    },
                    //icon: customIcon({
                    //    fillColor: $('#colorSelect').data('kendoDropDownList').value() //markerIconUrl
                    //}),
                    map: map,
                    animation: google.maps.Animation.DROP,
                    markerType: markerType,
                    index: index,
                });
                marker.addListener('click', helper.selectMarker);
                return marker;
            },
            addMarker: function (modelMarker) {

                let marker = helper.createGoogleMarker(
                    myLatLng = modelMarker.point,
                    map,
                    colorDataSource.find(x => x.markerIconId == modelMarker.markerIconId).iconUrl,
                    helper.getMarkerLable(modelMarker.index, modelMarker.markerType),
                    modelMarker.markerType,
                    modelMarker.index
                );
                // Add the marker at the clicked location, and add the next-available label
                // from the array of alphabetical characters.

                markers.push(marker);
            },
            getMarkerLable: function (markerIndex, markerType)
            {
                let lable;
                (markerType == 1) ? lable = "S" :
                    (markerType == 2) ? lable = "E" :
                        lable = markerIndex.toString();
                return {
                        text: lable, //labelIndex.toString(),//labels[labelIndex++ % labels.length],
                        // color: "#eb3a44",
                        fontSize: "16px",
                        fontWeight: "bold"

                    };
            },
            removeMarker: (e) => {
                var ww = e.currentTarget;
                var dataItem = grid.dataItem($(e.currentTarget).closest("tr"));
                actions.removeMarker(dataItem.markerId);
            },
            modelMarkers: {
                getFreeMarkerIndex: function (markerType) {
                    switch (markerType) {
                        case 1: // markerType = Start Point
                            colorDropDownList.enable(true);
                            colorDropDownList.dataSource.data(colorDataSource.filter(x => x.color != "White"));
                            colorDropDownList.select(0);
                            marketTypeDropDownList.select(0);
                            return 0;
                            break;
                        case 2: // markerType = End Point
                            return 10;
                            break;
                        default: // markerType = Way Point
                            for (var i = 1; i < 10; i++) {
                                if (!modelMarkers.find(x => x.index == i)) {
                                    return i;
                                }
                            }
                            return 1; // default first way point index
                            break;
                    }

                },
                changeMarkerPosition: (oldIndex, newIndex) => {
                    //var positionToInsert = modelMarkers.indexOf(modelMarkers.find(x => x.index == newIndex))

                    let hasStartMarker = modelMarkers.find(x => x.markerType == 1) != null;
                    let hasEndMarker = modelMarkers.find(x => x.markerType == 2) != null;


                    var item = modelMarkers.find(x => x.index == oldIndex);
                    modelMarkers = modelMarkers.filter(x => x.index != oldIndex);

                    //if (newIndex == 0 || newIndex == 10) {
                    //    modelMarkers.find(x => x.index == newIndex).markerType = item.markerType;
                    //    modelMarkers.find(x => x.index == newIndex).markerIconId = item.markerIconId;
                    //    modelMarkers.find(x => x.index == newIndex).markerIcon = colorDataSource.find(x => x.markerIconId == item.markerIconId);
                    //    if (newIndex == 0) {

                    //        item.markerType = 1;
                    //        item.markerIconId = 5;
                    //        item.markerIcon = colorDataSource.find(x => x.markerIconId == 5);
                    //    } else if (newIndex == 10) {
                    //        item.markerType = 2
                    //        item.markerIconId = 5;
                    //        item.markerIcon = colorDataSource.find(x => x.markerIconId == 5);
                    //    }
                    //} else {
                    //    if (item.markerType > 0) {
                    //        modelMarkers.find(x => x.index == newIndex).markerType = item.markerType;
                    //        modelMarkers.find(x => x.index == newIndex).markerIconId = item.markerIconId;
                    //        modelMarkers.find(x => x.index == newIndex).markerIcon = colorDataSource.find(x => x.markerIconId == item.markerIconId);
                    //        item.markerType = 0;
                    //        item.markerIconId = 1;
                    //        item.markerIcon = colorDataSource.find(x => x.markerIconId == 1);
                    //    }
                    //}

                    var timeMarkers = [];

                    if (oldIndex > newIndex) {
                        modelMarkers.filter(x => x.index < newIndex).forEach((m) => {
                            timeMarkers.push(m);
                        });

                        item.index = newIndex;
                        timeMarkers.push(item);

                        modelMarkers.filter(x => x.index >= newIndex && x.index < oldIndex).forEach((m) => {
                            m.index++;
                            timeMarkers.push(m);
                        })

                        modelMarkers.filter(x => x.index > oldIndex).forEach((m) => {
                          // m.index--;
                            timeMarkers.push(m);
                        })
                    } else
                    {
                        modelMarkers.filter(x => x.index < oldIndex).forEach((m) => {
                            timeMarkers.push(m);
                        });

                         modelMarkers.filter(x => x.index > oldIndex && x.index <= newIndex).forEach((m) => {
                            m.index--;
                            timeMarkers.push(m);
                        })

                        item.index = newIndex;
                        timeMarkers.push(item);

                        modelMarkers.filter(x => x.index > newIndex).forEach((m) => {
                            timeMarkers.push(m);
                        });
                    }

                    var index = hasStartMarker ? 0 : 1;
                    
                    timeMarkers.forEach((m) => {
                        m.index = index;

                        switch (index) {
                            case 0:
                                helper.modelMarkers.setMarkerType(m, 1);
                            case 10:
                                helper.modelMarkers.setMarkerType(m, 2);
                                break;
                            default:
                                helper.modelMarkers.setMarkerType(m, 0);
                        }

                        index++;
                    });

                    if (hasEndMarker) {
                        helper.modelMarkers.setMarkerType(timeMarkers[timeMarkers.length-1], 2);
                    }

                    modelMarkers = timeMarkers;



                    render.renderMarkersFromModel();
                    actions.updateMapMarkers(timeMarkers);
                },
                removeMarker: (markerId) => {
                    let removeMarkerIndex = modelMarkers.find(x => x.markerId == markerId).index;
                    modelMarkers = modelMarkers.filter(x => x.markerId != markerId);
                    modelMarkers.forEach((marker) => {
                        if (marker.index > removeMarkerIndex) {
                            marker.index--;
                        }
                    });
                    render.gridRefresh();
                    actions.updateMapMarkers(modelMarkers);
                },
                setMarkerType: (marker, markerType) => {
                    marker.markerType = markerType;
                    if (markerType > 0) {
                        marker.markerIconId = 5;
                        marker.markerIcon = colorDataSource.find(x => x.markerIconId == 5);
                        //marker.index = marker.markerType == 1 ? 0 : 10;
                    } else if (marker.markerIconId == 5) {
                        marker.markerIconId = 1;
                        marker.markerIcon = colorDataSource.find(x => x.markerIconId == 1);
                    }
                },
            },
            updateRoute: () => {
                if (polylines.length > 0) {
                    useSimpleRoute ? actions.getRoute() : actions.getOptimalRoute();
                }
            },
            selectMarker: (e) => {
               var selectedMarker = modelMarkers.find(x => x.point.lat.toFixed(2) == e.latLng.lat().toFixed(2) && x.point.lng.toFixed(2) == e.latLng.lng().toFixed(2))
                var row = grid.tbody.find("tr[data-uid='" + grid._data.find(x => x.index == selectedMarker.index).uid + "']");
                helper.animateMarker($(row)[0]);
            },
            animateMarker: (row) => {
             //   var selectedItem = grid.dataItem($(e.currentTarget).closest("tr"));

                markers.forEach((marker) => {
                    if (marker.getAnimation() !== null) {
                        marker.setAnimation(null);
                        marker.setLabel(helper.getMarkerLable(marker.index, marker.markerType));
                    }
                });

                var isRowSelected = $(row).hasClass('k-state-selected');
                $(row.parentElement).find("tr").removeClass('k-state-selected');

                if (isRowSelected) {
                    $(row).removeClass('k-state-selected');
                } else {
                    $(row).addClass('k-state-selected');
                    var selectedItem = grid.dataItem(grid.select());
                    var marker = markers.find(x => x.index == selectedItem.index);
                    marker.setLabel(null);
                    marker.setAnimation(google.maps.Animation.BOUNCE);
                }

                //$(e.currentTarget).toggleClass('k-state-selected');

                //var row = grid.select();
                //var data = grid.dataItem(row);


            },

        },
        render = {
            renderMarkersFromModel: () => {
                render.cleanMapMarkers();
                markers = [];
               // Add a markers from the viewModel.
                $.each(modelMarkers, function (index, item) {
                    helper.addMarker(item);
                });

                render.gridRefresh();
            },
            renderPolylines: (legs) => {

                render.clearPolylines();

                legs.forEach((leg) => {
                    var polyline = new google.maps.Polyline({
                        path: google.maps.geometry.encoding.decodePath(leg.polyline),
                        map: map
                    });
                    polylines.push(polyline);
                });

            },
            clearPolylines: () => {
                polylines.forEach((poly) => {
                    poly.setMap(null);
                });

                polylines = [];
            },
            updateMapMarkers: () => {
                render.cleanMapMarkers();
                render.setMapMarkers();
            },
            cleanMapMarkers: () => { //  Removes the markers from the map
                render.setMapOnAll(null);
            },
            setMapMarkers: () => {
                render.setMapOnAll(map);
                },
            setMapOnAll: (map) => { // Sets the map on all markers in the array.
                for (var i = 0; i < markers.length; i++) {
                    markers[i].setMap(map);
                }
            },
            gridRefresh: () => {
                grid.dataSource.data(modelMarkers);
            },
            formatDistance: (distance) => {
                return (distance / 1000).toFixed(2) + " km"
            },
            formatDuration: (duration) => {
                //var date = new Date(null);
                //date.setSeconds(duration; // specify value for SECONDS here
                //var timeString = date.toISOString().substr(11, 8);

                var date = new Date(duration * 1000);
                var hh = date.getUTCHours();
                var mm = date.getUTCMinutes();
                var ss = date.getSeconds();

                //if (hh < 10) { hh = "0" + hh; }
                //if (mm < 10) { mm = "0" + mm; }

                // This formats your string to HH:MM:SS
                //var t = hh + ":" + mm + ":" + ss;

                if (ss > 30) mm++;
                if (hh > 0) return hh + " h " + mm + " min";
                return mm + " min"
            },
        }


        function registerEventHandlers()
        {
            // This event listener calls addMarker() when the map is clicked.
            google.maps.event.addListener(map, 'click', function (event) {
                 let markerType = parseInt($("#markerType").val());
                //helper.addMarker(
                //    event.latLng,
                //    map,
                //    $('#colorSelect').data('kendoDropDownList').value(),
                //    helper.getMarkerLable(helper.modelMarkers.getFreeMarkerIndex(markerType), parseInt($("#markerType").val()))
                //);
                actions.addMapMarker(
                    {
                        Point: {
                            Lat: event.latLng.lat(),
                            Lng: event.latLng.lng(),
                        },
                        MarkerIconId: $('#colorSelect').data('kendoDropDownList').dataItem().markerIconId,
                        MarkerType: markerType,
                        Index: helper.modelMarkers.getFreeMarkerIndex(markerType)
                    }
                )
            });

            $('#deleteMarkers').click(actions.removeMapMarkers);
            $("#buildRoute").click(actions.getRoute);
            $("#btn-optimalRoute").click(actions.getOptimalRoute);

            $("#routeTable").on("click", " .k-grid-content table tr", (e) => {
                e.preventDefault();
                helper.animateMarker(e.currentTarget);
            });
        }


        function _init() {

            helper.initRouteTable();
            //google.maps.event.addDomListener(window, 'load', helper.initGoogleMap);
            helper.initGoogleMap();
            //setModelMarkers();
            helper.initIconsDropDownList();
            helper.initMarkerTypeDropDownList();
            helper.initRouteOptionsDropDownList();

                registerEventHandlers();
            }

            $(document).ready(function () {
                _init();
            });

        //});
    </script>

}



<style>
    /* Always set the map height explicitly to define the size of the div
        * element that contains the map. */
    #map {
        height: 100%;
        min-height: 500px;
    }
    /* Optional: Makes the sample page fill the window. */
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
    }

    .space-20 {
        height: 20px;
    }

    .margin-5 {
        margin: 5px;
    }

    #btn-optimalRoute {
        /*width: 200px;*/
        /* text-align: right; */
        /* float: right; */
        background-color: #d76161;
        /*box-shadow: 0px 3px 20px 2px black;*/
    }

    div#map {
        box-shadow: 0 0 20px 0px black;
    }

    .right {
        margin-left: auto;
    }
</style>





@*<div class="text-center">
        <h1 class="display-4">Welcome</h1>
        <p>Learn about <a href="https://docs.microsoft.com/aspnet/core">building Web apps with ASP.NET Core</a>.</p>
    </div>*@
